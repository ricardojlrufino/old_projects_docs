Mudar o nome do projeto para: ProjectFactory ou CodeFactory, verificar se j· existe projetos com esse nome.

OBS: Em 30/10/2011 - o documento oficial est· no google DOCS.
https://docs.google.com/document/d/1_pOl5T5UncNbT0ZCVcjLAiIG8ZYQ3DTdzBHmbRlfFL0/edit#

-----
O Nome do projecto vai ser: ProjectFactory ou ProjectSnnipet (um outro projeto de teste.)
 - pois ele ser· apenas um fabrica de cÛdigos baseado em templates, sem muita lÛgica
permitindo colocar isso no AR.
----

Essa estrutura de metaModel da ficando bem parruda, para n√£o reinventar a roda, ele pode serguir o modelo de uma ja existente.
ex: A do Jude, que j√° deve ter as formar de importa√ß√£o de Java, e de .Jude. E que j√° √© testada.
    Verificar a licen√ßa.


- Criar estrutura para que se possa gerar c√≥digo para qualquer linguagem e qualquer tecnologia de vis√£o ou persistencia, e qualquer framewrok
  inicialmente ser√°: Java, Hibernate, Mentawai/LinkzFramework, JSP.
               outro: Java, JPA, Struts2, JSP

- Para o uso imedia todo do quer for criado! 
  - criar modelo de classes main, por enquanto que n√£o existe os formul√°rios...
  ou melhor usar Tasks do Ant para gera√ß√£o, j√° que ser√° preciso quando se for gerar os arquivos.
  No build.properties, teria o nome ou os nomes das classes a serem analizadas, ou o nome do pacote.
  ---- (ideias depois da nova modelagem) ---- 
  Pode se criar um projeto que usa implementaÁıes est·ticas (que n„o usa interaÁ„o com os Winzards nem com Banco de Dados), e
  frameworks padrıes Mentawai, LinkzFramework, Hibernate.
  Nome do Projeto: ProjectNCodeManualGen (GeraÁ„o atravÈs de cÛdigo e mÈtodos MAIN), pode se implementar formul·rios simples Swing usando o
  NetBenas

  ---------------------------------------
  - DICAS DE IMPLEMENTA«√O E ESTRUTURA
  ---------------------------------------
Constantes de ConfiguraÁ„o do Analizer(interface AnalizerProperties):

# ConfiguraÁıes para todos os Analizers
analizer.global.invalid_resources = Igual, %Prefixo, Sufixo%, %Contem%, (suporte a expressoes regulares...)
analizer.global.dest_dir = c:/projects/projectx/src/new

# ConfiguraÁıes do: ReflectionAnalizer
analizer.source.used_option = analizer.reflection.class_name
analizer.reflection.class_name = br.com.projectx.Entity
analizer.reflection.package = br.com.projectx
analizer.reflection.include_subpackages =  true/false

# ConfiguraÁıes do: SourceAnalizer
analizer.source.src_dir = c:/projects/projectx/src
analizer.source.used_option = analizer.source.class_name
analizer.source.class_name = br.com.projectx.Entity
analizer.source.package = br.com.projectx
analizer.source.include_subpackages =  true|false

IDEIA: Implementar um Painel para configurar essa propriedades, assim como no Eclipse.



- Colocar nos codigos gerados  comentario :
   * Generated by ProjectNCode, a tool provided by
   * LinkzSistemas under GPL.
   * Please see www.site.com.br,for informations about this tool.
   - NOTA: os comentarios variam de linguagem pra linguagem, implementar as variaÁıes ou
      pelo menos o suporte a elas



- Um ponto importante e a manutenÁ„o dÛ cÛdigo gerado.
  Bolar estratÈgias de como sincronizar o cÛdigo novo com o gerado anteriormente, pode ser adotado no caso do
  de criar um plugins para o Eclipse, usar o mesmo sistema do SVN para comprar os arquivos, mas para isso seria preciso
  que os geradosres, ou BUILDERS, implementassem algum modo de PAUSA emquando o codigo e corrigido ou algo do tipo.


- Ao inves de usar as Factorys para criar o meta model, deve ser usado os Analizers, que tem esse objetivo
  criar: XMIAnalizer, JudeAnalizar, DBAnalizer, ClassAnalizer, JavaDocAnalizer, JspAnalizer..
 Isso caracteria a forma de importa√ß√£o de dados que o sistema suporta.

Pode existir ainda as factorys, para a cria√ß√£o de meta models padr√£o.

- Colocar um Movo MetaModel Assosiation, que extende o Field, para indicar o tipo de rela√ß√£o.
  Isso pode ser util para determinar se vai ser um <include> ou <extends>, que pode ser usado para gerar:
  - Formul√°rios.
  - Mapeamento do Hibernate.
  pode ser preciso colocar o tal do Role(tipo) para identificar os lados das associa√ß√µes.


- O ModedelMetaData deve ter um SuperClass, para indentificar as Heran√ßas, e quando deve usar o encapsulamento.
  Metodo adicionais, getDeclaratedFields(), getFields(), getDeclaratedAssosiations() , getAssosiations();
                                     ^-- Inclui as associa√ß√µes ou n√£o ?, pode ter um boolean como parametro para determinar isso.

- Criar uma Camada de Interfaces para o MetaModelo, assim como no Jude...
  - pode ser preciso para facilitar a gera√ß√£o das classes pelo viaual.p, sem perder a implementa√ß√£o que ja foi feita, analizar
    as vantagens e desvantagens disso).
  (de inicio ser√° preciso que todas as classes implementem a interface MetaData)
 - Colocar um atributo descri√ß√£o (que pode ser usado quando o metamodelo for classes que incluem l√≥gica, 
   exemplo pode ser preciso criar o MetaModel dos Analizers e Builders, usados nos winzards)
  - pode ser preciso cadastrar as interfaces que aquele MetaModel Implementa.

- Na classe FileTemplate, ao inves de ser um file, usar s√≥ a String mesmo, para que possa ser persistido no banco de dados.

Usar uma API de Visualiza√ß√£o de G≈ïaficos para ver o
- MetaModel (Da parte das Classes) e o MetaModel do Projeto (Action, Service, Etc....)
que pode ser usado para o usu√°rio ter uma vis√£o mais ampla do que j√° foi projeto, e que ser√° gerado.
